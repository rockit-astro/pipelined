#!/usr/bin/env python3
#
# This file is part of pipelined.
#
# pipelined is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pipelined is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pipelined.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for the Warwick one-metre telescope frame pipeline"""

# pylint: disable=too-few-public-methods
# pylint: disable=no-self-use
# pylint: disable=broad-except
# pylint: disable=invalid-name
# pylint: disable=too-many-instance-attributes

import math
import os
import shutil
import subprocess
import threading
import time
from astropy.io import fits
import Pyro4

# Set automatically when generating RPM package
SOFTWARE_VERSION = 'UNKNOWN'

PYRO_COMM_TIMEOUT = 5

PIPELINE_HOST = '192.168.0.101'
PIPELINE_PORT = 9012
PIPELINE_NAME = 'pipeline_daemon'

TELD_HOST = '192.168.0.101'
TELD_PORT = 9003
TELD_NAME = 'telescope_daemon'

TELD_URL = 'PYRO:' + TELD_NAME + '@' + TELD_HOST + ':' + str(TELD_PORT)

PIXELSHIFT_PATH = '/home/saft/src/pixelshift/pixelshift'

GUIDE_REFERENCE_FRAME_PATH = '/var/tmp/guide_reference.fits'

# Matrix coefficients transforming pixel offsets to sky offsets.
# These are just the [CD1_1, CD1_2, CD2_1, CD2_2] wcs parameters
GUIDE_TRANSFORM_MATRICES = {
    'BLUE': [0.000108685545277, -3.58470982799E-07,
             -2.98097156944E-07, -0.000108607868069],
    'RED': [-0.00010858955941, 1.83797853216E-07,
            -2.66674559873E-07, -0.000108601351771]
}

CAMERA_URLS = {
    'BLUE': 'PYRO:blue_camera_daemon@192.168.0.101:9011',
    'RED': 'PYRO:red_camera_daemon@192.168.0.101:9010'
}

GUIDE_FUDGE_FACTOR = 0.5

# This should be kept in sync with the dictionary in pipeline
class CommandStatus:
    """Numeric return codes"""
    # General error codes
    Succeeded = 0
    Failed = 1
    Blocked = 2

class TryLock(object):
    """Helper object for use with `with` statements"""
    def __init__(self, lock):
        self._lock = lock
        self._locked = False

    def __enter__(self):
        self._locked = self._lock.acquire(False)
        return self._locked

    def __exit__(self, *args):
        if self._locked:
            self._lock.release()
            self._locked = False

class PipelineDaemon:
    """Daemon interface for data pipeline"""
    def __init__(self):
        self._command_lock = threading.Lock()
        self._guide_condition = threading.Condition()
        self._guide_camera_id = None
        self._guide_latest_frame = None
        self._guide_x_binning = 1
        self._guide_y_binning = 1
        self._guide_background_tile_size = 0
        self._guide_reference_frame = None
        self._guide_last_guide_frame = None

        guide_thread = threading.Thread(target=self.__process_guide_frames)
        guide_thread.daemon = True
        guide_thread.start()

        self._reduction_condition = threading.Condition()
        self._reduction_enabled = False
        self._reduction_files = set()

        reduction_thread = threading.Thread(target=self.__update_reduction)
        reduction_thread.daemon = True
        reduction_thread.start()

        self._wcs_condition = threading.Condition()
        self._wcs_enabled = False
        self._wcs_files = set()

        wcs_thread = threading.Thread(target=self.__update_wcs)
        wcs_thread.daemon = True
        wcs_thread.start()

    def __process_guide_frames(self):
        """Calculates image shifts between frames and offsets telescope to compensate"""
        while True:
            # Block until a frame is available for processing
            frame = None
            with self._guide_condition:
                while self._guide_latest_frame is None:
                    self._guide_condition.wait()

                frame = self._guide_latest_frame
                self._guide_latest_frame = None

            # New guide session: take a copy of this frame to use as the reference
            if self._guide_reference_frame is None:
                print('taking', frame, 'as new guide reference')
                try:
                    self._guide_reference_frame = GUIDE_REFERENCE_FRAME_PATH
                    shutil.copy(frame, GUIDE_REFERENCE_FRAME_PATH)
                    reference = fits.open(GUIDE_REFERENCE_FRAME_PATH)
                    self._guide_x_binning = reference[0].header['CCD-XBIN']
                    self._guide_y_binning = reference[0].header['CCD-YBIN']
                    reference.close()
                except Exception as e:
                    print('failed with error: ' + str(e))
                continue

            if self._guide_camera_id not in GUIDE_TRANSFORM_MATRICES:
                print('no transform matrix for camera ' + self._guide_camera_id)
                continue

            try:
                output = subprocess.check_output(
                    [PIXELSHIFT_PATH, frame, self._guide_reference_frame,
                     str(self._guide_background_tile_size)], universal_newlines=True, timeout=5)

                t = GUIDE_TRANSFORM_MATRICES[self._guide_camera_id]
                coords = output.split(' ')

                # Measured offset in px
                dx = float(coords[0])
                dy = float(coords[1])

                # First-order approximated offset in ra, dec (degrees)
                dra = (t[0] * dx + t[1] * dy) * self._guide_x_binning
                ddec = (t[2] * dx + t[3] * dy) * self._guide_y_binning

                # Calculate actual telescope offset by running offsets through PID loop
                # TODO: This currently only accounts for proportional offsets (no history)
                guide_offset_ra = GUIDE_FUDGE_FACTOR * dra * math.pi / 180
                guide_offset_dec = GUIDE_FUDGE_FACTOR * ddec * math.pi / 180

                # TODO: Check for and drop anomalously large offsets

                print('offset px: {} {}; arcsec: {} {}'.format(dx, dy, 3600 * dra, 3600 * ddec))

                with Pyro4.Proxy(TELD_URL) as teld:
                    teld.offset_radec_guiding(guide_offset_ra, guide_offset_dec)
            except Exception as e:
                print('failed to update guiding with error: ' + str(e))

    def __update_reduction(self):
        """Updates the online reduction as frames are saved to disk"""
        while True:
            # Block until a frame is available for processing
            updated = None
            with self._reduction_condition:
                while len(self._reduction_files) == 0:
                    self._reduction_condition.wait()

                updated = self._reduction_files.copy()
                self._reduction_files.clear()

            for f in updated:
                print('will update reduction file `' + f + '` if it exists')
                if not os.path.isfile(f):
                    continue

                # TODO: Integrate reduction into the pipeline better
                try:
                    subprocess.check_call(['/home/saft/src/tsreduce/tsreduce', 'update', f])
                    subprocess.check_call(['/home/saft/src/tsreduce/tsreduce', 'plot', f])
                except Exception as e:
                    print('failed to update reduction with error: ' + str(e))

    def __update_wcs(self):
        """Calculates WCS solutions for the latest frame previews"""
        while True:
            # Block until a frame is available for processing
            updated = None
            with self._wcs_condition:
                while len(self._wcs_files) == 0:
                    self._wcs_condition.wait()

                updated = self._wcs_files.copy()
                self._wcs_files.clear()

            # Force a small delay to avoid racing against the camera's frame update
            time.sleep(1.0)
            for camera_id, path in updated:
                if camera_id not in CAMERA_URLS:
                    print('no pyro address for camera ' + camera_id)
                    return

                try:
                    frame = fits.open(path)
                    frame_ra = frame[0].header['TELRA']
                    frame_dec = frame[0].header['TELDEC']
                    frame.close()
                    args = [
                        '/usr/local/astrometry/bin/solve-field',
                        '--no-fits2fits', '--overwrite', '--no-plots',
                        '--axy', 'none', '--rdls', 'none', '--match', 'none',
                        '--corr', 'none', '--index-xyls', 'none',
                        '--solved', 'none', '--scale-units', 'arcminwidth',
                        '--scale-high', '13.4', '--ra', frame_ra, '--dec', frame_dec,
                        '--radius', '1.75', path]

                    subprocess.check_call(args, timeout=2.0, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

                    wcs_data = ''
                    with open(os.path.splitext(path)[0] + '.wcs') as wcs_file:
                        header = wcs_file.read()
                        # ds9 will only accept newline-delimited keys
                        # so we need to reformat the 80-character cards
                        for line in [header[i:i+80] for i in range(0, len(header), 80)]:
                            key = line[0:8].strip()
                            # Discard comment, history, and non-wcs cards
                            if '=' in line and key not in ['SIMPLE', 'BITPIX', 'NAXIS', 'EXTEND', 'DATE']:
                                # Strip unnecessary whitespace and comments
                                value = line[9:].split('/')[0].strip()
                                wcs_data += key + ' = ' + value + '\n'

                    if len(wcs_data) > 0:
                        with Pyro4.Proxy(CAMERA_URLS[camera_id]) as camd:
                            camd.update_previews([('wcs replace', wcs_data)])
                            print('updated preview wcs')

                except Exception as e:
                    print('failed to update wcs with error: ' + str(e))

    @Pyro4.expose
    def notify_latest_frame(self, camera_id, path):
        """Called by the camera daemons to notify that the latest frame file has been updated"""
        if self._guide_camera_id == camera_id:
            # The guiding only cares about the latest frame
            with self._guide_condition:
                self._guide_latest_frame = path
                self._guide_condition.notify()
            print('updated latest frame', camera_id, path)

        if self._wcs_enabled:
            with self._wcs_condition:
                self._wcs_files.add((camera_id, path))
                self._wcs_condition.notify()

    @Pyro4.expose
    def notify_saved_frame(self, camera_id, path):
        """Called by the camera daemons to notify that a new frame has been saved to disk"""
        if not self._reduction_enabled:
            return

        # The current version of the reduction code doesn't care about the individual
        # frame names - only the name of the tsreduce reduction file.  The reduction file
        # is expected to be in the frame save dir with a filename matching the frame prefix.
        reduction_file = path.rpartition('-')[0] + '.dat'
        with self._reduction_condition:
            self._reduction_files.add(reduction_file)
            self._reduction_condition.notify()

    @Pyro4.expose
    def set_guide_camera(self, camera_id, background_tile_size=0):
        """Sets the camera ID to use for guiding"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            self._guide_camera_id = camera_id
            self._guide_background_tile_size = background_tile_size
            self._guide_reference_frame = None
            self._guide_last_guide_frame = None

            return CommandStatus.Succeeded

    @Pyro4.expose
    def enable_reduction(self, enabled):
        """Enable or disable the online reduction"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            self._reduction_enabled = enabled

            return CommandStatus.Succeeded

    @Pyro4.expose
    def enable_wcs(self, enabled):
        """Enable or disable the online wcs updates"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            self._wcs_enabled = enabled

            return CommandStatus.Succeeded

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current pipeline state"""
        return {
            'reduction_enabled': self._reduction_enabled,
            'wcs_enabled': self._wcs_enabled,
            'guide_camera_id': self._guide_camera_id,
            'guide_background_tile_size': self._guide_background_tile_size,
            'guide_reference_frame': self._guide_reference_frame,
            'guide_last_guide_frame': self._guide_last_guide_frame
        }

def spawn_daemon():
    """Spawns the daemon and registers it with Pyro"""
    Pyro4.config.COMMTIMEOUT = PYRO_COMM_TIMEOUT
    Pyro4.config.REQUIRE_EXPOSE = True

    pyro = Pyro4.Daemon(host=PIPELINE_HOST, port=PIPELINE_PORT)
    pipeline = PipelineDaemon()
    uri = pyro.register(pipeline, objectId=PIPELINE_NAME)

    print('Starting pipeline daemon with Pyro ID:', uri)
    pyro.requestLoop()
    print('Stopping pipeline daemon with Pyro ID:', uri)

if __name__ == '__main__':
    spawn_daemon()
