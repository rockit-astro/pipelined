#!/usr/bin/env python3
#
# This file is part of pipelined.
#
# pipelined is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pipelined is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pipelined.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for the Warwick one-metre telescope frame pipeline"""

# pylint: disable=too-few-public-methods
# pylint: disable=no-self-use
# pylint: disable=broad-except
# pylint: disable=invalid-name
# pylint: disable=too-many-instance-attributes

import os
import subprocess
import threading
import Pyro4

# Set automatically when generating RPM package
SOFTWARE_VERSION = 'UNKNOWN'

PYRO_COMM_TIMEOUT = 5

PIPELINE_HOST = '192.168.0.101'
PIPELINE_PORT = 9012
PIPELINE_NAME = 'pipeline_daemon'

TELD_HOST = '192.168.0.101'
TELD_PORT = 9003
TELD_NAME = 'telescope_daemon'

TELD_URL = 'PYRO:' + TELD_NAME + '@' + TELD_HOST + ':' + str(TELD_PORT)

# This should be kept in sync with the dictionary in pipeline
class CommandStatus:
    """Numeric return codes"""
    # General error codes
    Succeeded = 0
    Failed = 1
    Blocked = 2

class TryLock(object):
    """Helper object for use with `with` statements"""
    def __init__(self, lock):
        self._lock = lock
        self._locked = False

    def __enter__(self):
        self._locked = self._lock.acquire(False)
        return self._locked

    def __exit__(self, *args):
        if self._locked:
            self._lock.release()
            self._locked = False

class PipelineDaemon:
    """Daemon interface for data pipeline"""
    def __init__(self):
        self._command_lock = threading.Lock()
        self._guide_condition = threading.Condition()
        self._guide_camera_id = None
        self._guide_latest_frame = None
        guide_thread = threading.Thread(target=self.__process_guide_frames)
        guide_thread.daemon = True
        guide_thread.start()

        self._reduction_condition = threading.Condition()
        self._reduction_enabled = False
        self._reduction_files = set()

        reduction_thread = threading.Thread(target=self.__update_reduction)
        reduction_thread.daemon = True
        reduction_thread.start()

    def __process_guide_frames(self):
        """Calculates image shifts between frames and offsets telescope to compensate"""
        while True:
            # Block until a frame is available for processing
            frame = None
            with self._guide_condition:
                while self._guide_latest_frame is None:
                    self._guide_condition.wait()

                frame = self._guide_latest_frame
                self._guide_latest_frame = None

            # TODO: Integrate guiding into the pipeline better
            print('guiding on', frame)
            try:
                subprocess.check_call(['/home/saft/src/teld/tel', 'guide', 'update', frame])
            except Exception as e:
                print('failed to update guiding with error: ' + str(e))

    def __update_reduction(self):
        """Updates the online reduction as frames are saved to disk"""
        while True:
            # Block until a frame is available for processing
            updated = None
            with self._reduction_condition:
                while len(self._reduction_files) == 0:
                    self._reduction_condition.wait()

                updated = self._reduction_files.copy()
                self._reduction_files.clear()

            for f in updated:
                print('will update reduction file `' + f + '` if it exists')
                if not os.path.isfile(f):
                    continue

                # TODO: Integrate reduction into the pipeline better
                try:
                    subprocess.check_call(['/home/saft/src/tsreduce', 'update', f])
                    subprocess.check_call(['/home/saft/src/tsreduce', 'plot', f])
                except Exception as e:
                    print('failed to update reduction with error: ' + str(e))

    @Pyro4.expose
    def notify_latest_frame(self, camera_id, path):
        """Called by the camera daemons to notify that the latest frame file has been updated"""
        if self._guide_camera_id != camera_id:
            return

        # The guiding only cares about the latest frame
        with self._guide_condition:
            self._guide_latest_frame = path
            self._guide_condition.notify()
        print('updated latest frame', camera_id, path)

    @Pyro4.expose
    def notify_saved_frame(self, camera_id, path):
        """Called by the camera daemons to notify that a new frame has been saved to disk"""
        if not self._reduction_enabled:
            return

        # The current version of the reduction code doesn't care about the individual
        # frame names - only the name of the tsreduce reduction file.  The reduction file
        # is expected to be in the frame save dir with a filename matching the frame prefix.
        reduction_file = path.rpartition('-')[0] + '.dat'
        with self._reduction_condition:
            self._reduction_files.add(reduction_file)
            self._reduction_condition.notify()

    @Pyro4.expose
    def set_guide_camera(self, camera_id):
        """Sets the camera ID to use for guiding"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            self._guide_camera_id = camera_id

            return CommandStatus.Succeeded

    @Pyro4.expose
    def enable_reduction(self, enabled):
        """Enable or disable the online reduction"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            self._reduction_enabled = enabled

            return CommandStatus.Succeeded

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current pipeline state"""
        return {
            'reduction_enabled': self._reduction_enabled,
            'guide_camera_id': self._guide_camera_id
        }

def spawn_daemon():
    """Spawns the daemon and registers it with Pyro"""
    Pyro4.config.COMMTIMEOUT = PYRO_COMM_TIMEOUT
    Pyro4.config.REQUIRE_EXPOSE = True

    pyro = Pyro4.Daemon(host=PIPELINE_HOST, port=PIPELINE_PORT)
    pipeline = PipelineDaemon()
    uri = pyro.register(pipeline, objectId=PIPELINE_NAME)

    print('Starting pipeline daemon with Pyro ID:', uri)
    pyro.requestLoop()
    print('Stopping pipeline daemon with Pyro ID:', uri)

if __name__ == '__main__':
    spawn_daemon()
